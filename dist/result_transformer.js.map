{"version":3,"sources":["../src/result_transformer.js"],"names":["ResultFormat","padTimeSeriesAndSortByDate","transformDataToTable","rows","options","datapoints","_","map","row","timestamp","value","target","resultTarget","transformDataToTimeSeries","analyticsResult","groupBys","data","groupBy","series","datapointsCnt","interval","fromDate","Date","start","getTime","toDate","end","length","groupings","metricLabel","push","Object","keys","key","groupData","orderBy","paddedSeries","result","transform","response","config","resultFormat","TABLE","tableData","TIME_SERIES"],"mappings":"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","sourcesContent":["import {ResultFormat} from './types/resultFormat';\nimport {padTimeSeriesAndSortByDate} from './utils';\n\nconst transformDataToTable = (rows, options) => {\n  let datapoints = _.map(rows, row => {\n    const timestamp = row[0];\n    const value = row[1];\n    return [value, timestamp];\n  });\n\n  return {\n    target: options.resultTarget,\n    datapoints: datapoints\n  }\n}\n\nconst transformDataToTimeSeries = (analyticsResult, options) => {\n  const groupBys = options.data.groupBy;\n  const series = [];\n  let datapointsCnt = 0;\n\n  const interval = options.data.interval;\n  const fromDate = new Date(options.data.start).getTime();\n  const toDate = new Date(options.data.end).getTime();\n  if (groupBys.length > 0) {\n    let groupings = {};\n    _.map(analyticsResult.rows, row => {\n      const metricLabel = row[1];\n      if (!groupings[metricLabel]) {\n        groupings[metricLabel] = [];\n      }\n      const value = row[2];\n      const timestamp = row[0];\n      groupings[metricLabel].push([value, timestamp]);\n      datapointsCnt++;\n    });\n    for (let key of Object.keys(groupings)) {\n      const datapoints = groupings[key];\n      const groupData = {\n        target: key,\n        datapoints: _.orderBy(datapoints, [1], 'asc')\n      }\n      series.push(groupData);\n    }\n  } else {\n    const paddedSeries = padTimeSeriesAndSortByDate(analyticsResult.rows, fromDate, toDate, interval);\n    let result =  transformDataToTable(paddedSeries, options);\n    result.datapoints = _.orderBy(result.datapoints, [1], 'asc');\n    series.push(result);\n    datapointsCnt = result.datapoints.length\n  }\n  return {\n    series,\n    datapointsCnt\n  };\n}\n\nexport const transform = (response, options) => {\n  const analyticsResult = response.data.data.result;\n  const config = response.config;\n  if (config.resultFormat === ResultFormat.TABLE) {\n    const tableData = transformDataToTable(analyticsResult.rows, config)\n    return {\n      series: [tableData],\n      datapointsCnt: tableData.datapoints.length\n    };\n  } else if (config.resultFormat === ResultFormat.TIME_SERIES) {\n    return transformDataToTimeSeries(analyticsResult, config);\n  }\n}\n"],"file":"result_transformer.js"}