{"version":3,"sources":["../src/result_transformer.js"],"names":["ResultFormat","padTimeSeriesAndSortByDate","transformDataToTable","rows","options","datapoints","_","map","row","timestamp","value","target","resultTarget","transformDataToTimeSeries","analyticsResult","groupBys","data","groupBy","results","interval","fromDate","Date","start","getTime","toDate","end","length","groupings","metricLabel","push","Object","keys","key","series","orderBy","paddedSeries","result","transform","response","config","resultFormat","TABLE","TIME_SERIES"],"mappings":";;;;;;;;AAAQA,MAAAA,Y,sBAAAA,Y;;AACAC,MAAAA,0B,UAAAA,0B;;;AAEFC,MAAAA,oB,GAAuB,SAAvBA,oBAAuB,CAACC,IAAD,EAAOC,OAAP,EAAmB;AAC9C,YAAIC,UAAU,GAAGC,CAAC,CAACC,GAAF,CAAMJ,IAAN,EAAY,UAAAK,GAAG,EAAI;AAClC,cAAMC,SAAS,GAAGD,GAAG,CAAC,CAAD,CAArB;AACA,cAAME,KAAK,GAAGF,GAAG,CAAC,CAAD,CAAjB;AACA,iBAAO,CAACE,KAAD,EAAQD,SAAR,CAAP;AACD,SAJgB,CAAjB;;AAMA,eAAO;AACLE,UAAAA,MAAM,EAAEP,OAAO,CAACQ,YADX;AAELP,UAAAA,UAAU,EAAEA;AAFP,SAAP;AAID,O;;AAEKQ,MAAAA,yB,GAA4B,SAA5BA,yBAA4B,CAACC,eAAD,EAAkBV,OAAlB,EAA8B;AAC9D,YAAMW,QAAQ,GAAGX,OAAO,CAACY,IAAR,CAAaC,OAA9B;AACA,YAAMC,OAAO,GAAG,EAAhB;AAEA,YAAMC,QAAQ,GAAGf,OAAO,CAACY,IAAR,CAAaG,QAA9B;AACA,YAAMC,QAAQ,GAAG,IAAIC,IAAJ,CAASjB,OAAO,CAACY,IAAR,CAAaM,KAAtB,EAA6BC,OAA7B,EAAjB;AACA,YAAMC,MAAM,GAAG,IAAIH,IAAJ,CAASjB,OAAO,CAACY,IAAR,CAAaS,GAAtB,EAA2BF,OAA3B,EAAf;;AACA,YAAIR,QAAQ,CAACW,MAAT,GAAkB,CAAtB,EAAyB;AACvB,cAAIC,SAAS,GAAG,EAAhB;;AACArB,UAAAA,CAAC,CAACC,GAAF,CAAMO,eAAe,CAACX,IAAtB,EAA4B,UAAAK,GAAG,EAAI;AACjC,gBAAMoB,WAAW,GAAGpB,GAAG,CAAC,CAAD,CAAvB;;AACA,gBAAI,CAACmB,SAAS,CAACC,WAAD,CAAd,EAA6B;AAC3BD,cAAAA,SAAS,CAACC,WAAD,CAAT,GAAyB,EAAzB;AACD;;AACD,gBAAMlB,KAAK,GAAGF,GAAG,CAAC,CAAD,CAAjB;AACA,gBAAMC,SAAS,GAAGD,GAAG,CAAC,CAAD,CAArB;AACAmB,YAAAA,SAAS,CAACC,WAAD,CAAT,CAAuBC,IAAvB,CAA4B,CAACnB,KAAD,EAAQD,SAAR,CAA5B;AACD,WARD;;AASA,0CAAgBqB,MAAM,CAACC,IAAP,CAAYJ,SAAZ,CAAhB,kCAAwC;AAAnC,gBAAIK,GAAG,mBAAP;AACH,gBAAM3B,UAAU,GAAGsB,SAAS,CAACK,GAAD,CAA5B;AACA,gBAAMC,MAAM,GAAG;AACbtB,cAAAA,MAAM,EAAEqB,GADK;AAEb3B,cAAAA,UAAU,EAAEC,CAAC,CAAC4B,OAAF,CAAU7B,UAAV,EAAsB,CAAC,CAAD,CAAtB,EAA2B,KAA3B;AAFC,aAAf;AAIAa,YAAAA,OAAO,CAACW,IAAR,CAAaI,MAAb;AACD;AACF,SAnBD,MAmBO;AACL,cAAME,YAAY,GAAGlC,0BAA0B,CAACa,eAAe,CAACX,IAAjB,EAAuBiB,QAAvB,EAAiCI,MAAjC,EAAyCL,QAAzC,CAA/C;AACA,cAAIiB,MAAM,GAAIlC,oBAAoB,CAACiC,YAAD,EAAe/B,OAAf,CAAlC;AACAgC,UAAAA,MAAM,CAAC/B,UAAP,GAAoBC,CAAC,CAAC4B,OAAF,CAAUE,MAAM,CAAC/B,UAAjB,EAA6B,CAAC,CAAD,CAA7B,EAAkC,KAAlC,CAApB;AACAa,UAAAA,OAAO,CAACW,IAAR,CAAaO,MAAb;AACD;;AACD,eAAOlB,OAAP;AACD,O;;2BAEYmB,S,GAAY,SAAZA,SAAY,CAACC,QAAD,EAAWlC,OAAX,EAAuB;AAC9C,YAAMU,eAAe,GAAGwB,QAAQ,CAACtB,IAAT,CAAcA,IAAd,CAAmBoB,MAA3C;AACA,YAAMG,MAAM,GAAGD,QAAQ,CAACC,MAAxB;;AACA,YAAIA,MAAM,CAACC,YAAP,KAAwBxC,YAAY,CAACyC,KAAzC,EAAgD;AAC9C,iBAAO,CAACvC,oBAAoB,CAACY,eAAe,CAACX,IAAjB,EAAuBoC,MAAvB,CAArB,CAAP;AACD,SAFD,MAEO,IAAIA,MAAM,CAACC,YAAP,KAAwBxC,YAAY,CAAC0C,WAAzC,EAAsD;AAC3D,iBAAO7B,yBAAyB,CAACC,eAAD,EAAkByB,MAAlB,CAAhC;AACD;AACF,O","sourcesContent":["import {ResultFormat} from './types/resultFormat';\nimport {padTimeSeriesAndSortByDate} from './utils';\n\nconst transformDataToTable = (rows, options) => {\n  let datapoints = _.map(rows, row => {\n    const timestamp = row[0];\n    const value = row[1];\n    return [value, timestamp];\n  });\n\n  return {\n    target: options.resultTarget,\n    datapoints: datapoints\n  }\n}\n\nconst transformDataToTimeSeries = (analyticsResult, options) => {\n  const groupBys = options.data.groupBy;\n  const results = [];\n\n  const interval = options.data.interval;\n  const fromDate = new Date(options.data.start).getTime();\n  const toDate = new Date(options.data.end).getTime();\n  if (groupBys.length > 0) {\n    let groupings = {};\n    _.map(analyticsResult.rows, row => {\n      const metricLabel = row[1];\n      if (!groupings[metricLabel]) {\n        groupings[metricLabel] = [];\n      }\n      const value = row[2];\n      const timestamp = row[0];\n      groupings[metricLabel].push([value, timestamp]);\n    });\n    for (let key of Object.keys(groupings)) {\n      const datapoints = groupings[key];\n      const series = {\n        target: key,\n        datapoints: _.orderBy(datapoints, [1], 'asc')\n      }\n      results.push(series);\n    }\n  } else {\n    const paddedSeries = padTimeSeriesAndSortByDate(analyticsResult.rows, fromDate, toDate, interval);\n    let result =  transformDataToTable(paddedSeries, options);\n    result.datapoints = _.orderBy(result.datapoints, [1], 'asc');\n    results.push(result);\n  }\n  return results;\n}\n\nexport const transform = (response, options) => {\n  const analyticsResult = response.data.data.result;\n  const config = response.config;\n  if (config.resultFormat === ResultFormat.TABLE) {\n    return [transformDataToTable(analyticsResult.rows, config)];\n  } else if (config.resultFormat === ResultFormat.TIME_SERIES) {\n    return transformDataToTimeSeries(analyticsResult, config);\n  }\n}\n"],"file":"result_transformer.js"}