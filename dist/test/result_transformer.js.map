{"version":3,"sources":["../../src/result_transformer.js"],"names":["transformDataToTable","rows","options","datapoints","_","map","row","timestamp","value","target","resultTarget","transformDataToTimeSeries","analyticsResult","groupBys","data","groupBy","series","datapointsCnt","interval","fromDate","Date","start","getTime","toDate","end","length","groupings","metricLabel","push","Object","keys","key","groupData","orderBy","paddedSeries","result","transform","response","config","resultFormat","ResultFormat","TABLE","tableData","TIME_SERIES"],"mappings":"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","sourcesContent":["import {ResultFormat} from './types/resultFormat';\nimport {padTimeSeriesAndSortByDate} from './utils';\n\nconst transformDataToTable = (rows, options) => {\n  let datapoints = _.map(rows, row => {\n    const timestamp = row[0];\n    const value = row[1];\n    return [value, timestamp];\n  });\n\n  return {\n    target: options.resultTarget,\n    datapoints: datapoints\n  }\n}\n\nconst transformDataToTimeSeries = (analyticsResult, options) => {\n  const groupBys = options.data.groupBy;\n  const series = [];\n  let datapointsCnt = 0;\n\n  const interval = options.data.interval;\n  const fromDate = new Date(options.data.start).getTime();\n  const toDate = new Date(options.data.end).getTime();\n  if (groupBys.length > 0) {\n    let groupings = {};\n    _.map(analyticsResult.rows, row => {\n      const metricLabel = row[1];\n      if (!groupings[metricLabel]) {\n        groupings[metricLabel] = [];\n      }\n      const value = row[2];\n      const timestamp = row[0];\n      groupings[metricLabel].push([value, timestamp]);\n      datapointsCnt++;\n    });\n    for (let key of Object.keys(groupings)) {\n      const datapoints = groupings[key];\n      const groupData = {\n        target: key,\n        datapoints: _.orderBy(datapoints, [1], 'asc')\n      }\n      series.push(groupData);\n    }\n  } else {\n    const paddedSeries = padTimeSeriesAndSortByDate(analyticsResult.rows, fromDate, toDate, interval);\n    let result =  transformDataToTable(paddedSeries, options);\n    result.datapoints = _.orderBy(result.datapoints, [1], 'asc');\n    series.push(result);\n    datapointsCnt = result.datapoints.length\n  }\n  return {\n    series,\n    datapointsCnt\n  };\n}\n\nexport const transform = (response, options) => {\n  const analyticsResult = response.data.data.result;\n  const config = response.config;\n  if (config.resultFormat === ResultFormat.TABLE) {\n    const tableData = transformDataToTable(analyticsResult.rows, config)\n    return {\n      series: [tableData],\n      datapointsCnt: tableData.datapoints.length\n    };\n  } else if (config.resultFormat === ResultFormat.TIME_SERIES) {\n    return transformDataToTimeSeries(analyticsResult, config);\n  }\n}\n"],"file":"result_transformer.js"}